\documentclass[a4paper,12pt]{article}

\usepackage[a4paper, inner=1.7cm, outer=2.7cm, top=1.5cm, bottom=2cm, bindingoffset=1.2cm]{geometry}
\usepackage[german]{babel}
\usepackage{microtype}
\usepackage{fancyhdr}
\usepackage{hyperref}
\usepackage[pdftex]{graphicx}

\pagestyle{fancy}
\fancyfoot[C]{\thepage}

\newcommand{\myparagraph}[1]{\paragraph*{#1}\mbox{}\\}

\title{Dokumentation zur Projektaufgabe für das Modul Künstliche Intelligenz für Spiele im Wintersemester 2022/23} 
\author{Oliver Jakobs}

\begin{document}

\maketitle

\section*{Thema und Motivation}

Als Thema für meine Modulaufgabe habe ich mich für \textbf{Decision Trees} entschieden. 

Einlesen eines Decision Trees aus einer XML-Datei und Frage-Antwort Spiel oder textbasiertes Adventure.

Das Konzept lässt sich neben künstlicher Intelligenz auch auf viele andere Bereiche anwenden. Ein Beispiel ist eine Alternative zu Zustandsautomaten um festzulegen welche Animation gespilet werden soll.

\newpage

\section*{Allgemeine Designentscheidungen}

Mein Programm lässt sich in zwei Abschnitte aufteilen. Der erste Teil ist die Implementiation des Decision Tress. Dieser wird aus einer .xml-Datei eingelesen und in eine passenden Datenstruktur geladen. 
Den zweiten Teil habe ich TreeWalker gennant. Dieser Teil beschäftigt sich mit Kommunikation zwischen dem Nutzer und dem Baum. 
\\
\\
Das Programm habe ich bewusst im C-Style programmiert. Das heißt ich habe mich bei der Struktur des Programmes an C gehalten und habe lediglich einzelene Features (z.B. \texttt{std::vector} oder \texttt{std::variant}) aus C++ verwendet.
Der Grund für diese Entscheidung war, dass ich privat hauptsächlich in C programmiere und so am komfortabelsten mit diesem Stil bin. Außerdem habe ich so weniger Aufwand, wenn ich die Implementation anpassen muss, wenn ich Decision Trees in meinen C-Programmen verwenden will.
\\
\\

\section*{Entscheidungen zur DecisionTree Implementation}
Der DecisionTree wird aus mehreren TreeNodes aufgebaut. So eine TreeNode hat einen Type, einen Namen, einen Wert und eine Liste an Nachfolgern. Der Type gibt an ob es sich um einen Knoten oder um ein Blatt des Baumes handelt, und um was für eine Art Entschiedung es sich handelt. Dabei werden zwei Arten unterscheiden: 

\myparagraph{Decision}
Eine \texttt{decision} bildet den Grundbaustein meiner Implementation. An sich lässt sich alle Funktionalität von DecisionTrees nur mit TreeNodes dieser Art umsetzen.
Der Wert einer \texttt{decision} ist eine Boolean Expression, in die zum Zeitpunkt der Entscheidung eine Variable eingesetzt werden kann. 

\myparagraph{Option}
Eine \texttt{option} ist ein Spezialfall der Decision
\\
\\


\section*{Entscheidungen zur XML-Datei}
Ich bin eigentlich kein Fan vom XML Dateiformat, aber um Baumstrukturen darzustellen ist es die einfachste und verbreitetsten Form.

Der eigentliche DecisionTree besteht aus drei Tags (\texttt{decision}, \texttt{option}, \texttt{final}).
Diese Tags entsprechen dem Type des aus dem Element generierten TreeNode.
Der \texttt{final}-Tag dient lediglich der anschaulicheren Darstellung und im generierten Baum hat jede TreeNode den Type \texttt{final}, wenn dieser keine Nachfolger hat.
Jedes Element mit einem dieser Tags kann als Attribut einen Namen und einen Wert haben.
Der Name gibt den Namen der Entscheidung an, die dieses Element repräsentiert. 

\myparagraph{Tag: \texttt{decision}}
Der \verb+decision+-Tag ist der grundlegende Baustein des DecisionTrees. 

Für den TreeWalker kann man noch einen weiteren Tag (\verb+prompt+) angeben, der dem TreeWalker zusätzliche Informationen gibt. Mit deisem Tag lässt sich angeben welche Frage der TreeWalker für eine Entscheidung stellen soll. 


\newpage
\section*{Bedienung}

Um das Programm zu starten muss die Datei \texttt{MeshSimplifier.exe} ausgeführt werden. Dafür wird neben der \texttt{.exe} auch der gesammte Inhalt des Orderns \texttt{./res/} benötigt.
\\
\\
Die Ausführung des Programms findet in einem \texttt{read-eval-print loop (REPL)} statt. Dem Nutzer wird eine Frage gestellt, auf die er dann antworten muss. Ist die Antwort ungültig, das heißt die Antwort entspricht nicht der erwarteten Form oder ist keine der möglichen Antwortmöglichkeiten, so wird der Nutzer erneut aufgefordert zu antworten. 

\section*{Bibliotheken}

Da dieses Projekt textbasiert ist benötige ich nur eine Möglichkeit XML-Dateien einzulesen. Für diese Funktionalität habe ich mich für die Bibliothek \textbf{TinyXML-2} (\url{https://github.com/leethomason/tinyxml2}) entschieden.
 

\section*{Build}

Zur Project Generation benutze ich Premake (\url{https://premake.github.io/}). Ich habe die entsprechenden Scripts meiner Abgabe beigefügt.
Falls also Probleme mit der VisualStudio Solution autreten sollten,
kann mit dem folgenden Befehl das Projekt neu generiert werden und so die Probleme hoffentlich gelöst werden:
\[\texttt{.\textbackslash premake\textbackslash premake5.exe [action]}\]
Für mein Projekt habe ich \texttt{vs2019} als \texttt{action} verwendet. Andere Möglichkeiten sind hier \url{https://premake.github.io/docs/Using-Premake} aufgelistet.


\end{document}